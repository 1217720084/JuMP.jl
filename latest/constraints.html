<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="JuMP logo"/></a><h1>JuMP</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="installation.html">Installation Guide</a></li><li><a class="toctext" href="quickstart.html">Quick Start Guide</a></li><li><a class="toctext" href="concepts.html">Concepts</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="expressions.html">Expressions</a></li><li class="current"><a class="toctext" href="constraints.html">Constraints</a><ul class="internal"><li><a class="toctext" href="#Sets-1">Sets</a></li><li><a class="toctext" href="#Constraint-modifications-1">Constraint modifications</a></li><li><a class="toctext" href="#Duals-1">Duals</a></li></ul></li><li><a class="toctext" href="containers.html">Containers</a></li><li><a class="toctext" href="names.html">Names</a></li><li><a class="toctext" href="solvers.html">Solvers</a></li><li><a class="toctext" href="nlp.html">Nonlinear Modeling</a></li><li><a class="toctext" href="style.html">Style Guide</a></li><li><a class="toctext" href="extensions.html">Extensions</a></li><li><a class="toctext" href="updating.html">Updating Guide</a></li><li><a class="toctext" href="howdoi.html">How do I ...? (FAQ)</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="constraints.html">Constraints</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/docs/src/constraints.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Constraints</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h1><p>DRAFT: Describe how constraints are represented (link to MOI docs). Constraints are very similar to variables in (1) how names work (2) how attributes work, and (3) the macro syntax for constructing them. They&#39;re a bit different because they&#39;re parameterized by function-set type. Describe constraints vs. <code>ConstraintRefs</code>. Describe <code>JuMP.constraint_object</code>. How to delete constraints. How to modify constraints by setting attributes and <code>MOI.modifyconstraint!</code>. Describe semidefinite constraints and symmetry handling. Refer to NLP docs for nonlinear constraints.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@constraint" href="#JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@constraint(m::Model, expr)</code></pre><p>Add a constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@constraint(m::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> can either be</p><ul><li>of the form <code>func in set</code> constraining the function <code>func</code> to belong to the set <code>set</code> which is either a <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1"><code>MathOptInterface.AbstractSet</code></a> or one of the JuMP shortcuts <a href="constraints.html#JuMP.SecondOrderCone"><code>SecondOrderCone</code></a>, <a href="constraints.html#JuMP.RotatedSecondOrderCone"><code>RotatedSecondOrderCone</code></a> and <a href="constraints.html#JuMP.PSDCone"><code>PSDCone</code></a>, e.g. <code>@constraint(model, [1, x-1, y-2] in SecondOrderCone())</code> constrains the norm of <code>[x-1, y-2]</code> be less than 1;</li><li>of the form <code>a sign b</code>, where <code>sign</code> is one of <code>==</code>, <code>≥</code>, <code>&gt;=</code>, <code>≤</code> and <code>&lt;=</code> building the single constraint enforcing the comparison to hold for the expression <code>a</code> and <code>b</code>, e.g. <code>@constraint(m, x^2 + y^2 == 1)</code> constrains <code>x</code> and <code>y</code> to lie on the unit circle;</li><li>of the form <code>a ≤ b ≤ c</code> or <code>a ≥ b ≥ c</code> (where <code>≤</code> and <code>&lt;=</code> (resp. <code>≥</code> and <code>&gt;=</code>) can be used interchangeably) constraining the paired the expression <code>b</code> to lie between <code>a</code> and <code>c</code>;</li><li>of the forms <code>@constraint(m, a .sign b)</code> or <code>@constraint(m, a .sign b .sign c)</code> which broadcast the constraint creation to each element of the vectors.</li></ul><p><strong>Note for extending the constraint macro</strong></p><p>Each constraint will be created using <code>add_constraint(m, build_constraint(_error, func, set))</code> where</p><ul><li><code>_error</code> is an error function showing the constraint call in addition to the error message given as argument,</li><li><code>func</code> is the expression that is constrained</li><li>and <code>set</code> is the set in which it is constrained to belong.</li></ul><p>For <code>expr</code> of the first type (i.e. <code>@constraint(m, func in set)</code>), <code>func</code> and <code>set</code> are passed unchanged to <code>build_constraint</code> but for the other types, they are determined from the expressions and signs. For instance, <code>@constraint(m, x^2 + y^2 == 1)</code> is transformed into <code>add_constraint(m, build_constraint(_error, x^2 + y^2, MOI.EqualTo(1.0)))</code>.</p><p>To extend JuMP to accept new constraints of this form, it is necessary to add the corresponding methods to <code>build_constraint</code>. Note that this will likely mean that either <code>func</code> or <code>set</code> will be some custom type, rather than e.g. a <code>Symbol</code>, since we will likely want to dispatch on the type of the function or set appearing in the constraint.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@SDconstraint" href="#JuMP.@SDconstraint"><code>JuMP.@SDconstraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@SDconstraint(model::Model, expr)</code></pre><p>Add a semidefinite constraint described by the expression <code>expr</code>.</p><pre><code class="language-none">@SDconstraint(model::Model, ref[i=..., j=..., ...], expr)</code></pre><p>Add a group of semidefinite constraints described by the expression <code>expr</code> parametrized by <code>i</code>, <code>j</code>, ...</p><p>The expression <code>expr</code> needs to be of the form <code>a sign b</code> where <code>sign</code> is <code>⪰</code>, <code>≥</code>, <code>&gt;=</code>, <code>⪯</code>, <code>≤</code> or <code>&lt;=</code> and <code>a</code> and <code>b</code> are <code>square</code> matrices. It constrains the matrix <code>x = a - b</code> (or <code>x = b - a</code> if the sign is <code>⪯</code>, <code>≤</code> or <code>&lt;=</code>) to be symmetric and positive semidefinite.</p><p>By default, we check numerical symmetry of the matrix <code>x</code>, and if symmetry is violated by some arbitrary amount, we add explicit equality constraints. You can use <code>Symmetric(x) in PSDCone()</code> with the <a href="constraints.html#JuMP.@constraint"><code>@constraint</code></a> macro to skip these checks if you know the matrix must be symmetric; see <a href="constraints.html#JuMP.PSDCone"><code>PSDCone</code></a> for more information.</p><p><strong>Examples</strong></p><p>The following constrains the matrix <code>[x-1 2x-2; -3 x-4]</code> to be symmetric and positive semidefinite, that is, it constrains <code>2x-2</code> to be equal to <code>-3</code> and constrains all eigenvalues of the matrix to be nonnegative.</p><pre><code class="language-julia-repl">julia&gt; using JuMP

julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [x 2x
            0  x];

julia&gt; b = [1 2
            3 4];

julia&gt; @SDconstraint(model, a ⪰ b)
[x - 1, -3, 2 x - 2, x - 4] ∈ MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>In the set <code>PositiveSemidefiniteConeSquare(2)</code> in the last output, <code>Square</code> means that the matrix is passed as a square matrix as the corresponding off-diagonal entries need to be constrained to be equal. A similar set <code>PositiveSemidefiniteConeTriangle</code> exists which only uses the upper triangular part of the matrix assuming that it is symmetric, see <a href="constraints.html#JuMP.PSDCone"><code>PSDCone</code></a> to see how to use it.</p></div></div></section><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>As mentioned in the documentation of the <a href="constraints.html#JuMP.@constraint"><code>@constraint</code></a> and <a href="constraints.html#JuMP.@SDconstraint"><code>@SDconstraint</code></a> macros, the following sets can be used to create constraints in addition to <a href="http://www.juliaopt.org/MathOptInterface.jl/v0.6.2/apireference.html#Sets-1">any MOI set</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.SecondOrderCone" href="#JuMP.SecondOrderCone"><code>JuMP.SecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SecondOrderCone</code></pre><p>Second order cone object that can be used to constrain the euclidean norm of a vector <code>x</code> to be less than or euqal to a nonnegative scalar <code>t</code>. This is a shortcut for the <code>MathOptInterface.SecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le t$</span> and <span>$t \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x-1, x-2] in SecondOrderCone())
[t, x - 1, x - 2] ∈ MathOptInterface.SecondOrderCone(3)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.RotatedSecondOrderCone" href="#JuMP.RotatedSecondOrderCone"><code>JuMP.RotatedSecondOrderCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">RotatedSecondOrderCone</code></pre><p>Rotated second order cone object that can be used to constrain the square of the euclidean norm of a vector <code>x</code> to be less than or equal to <span>$2tu$</span> where <code>t</code> and <code>u</code> are nonnegative scalars. This is a shortcut for the <code>MathOptInterface.RotatedSecondOrderCone</code>.</p><p><strong>Examples</strong></p><p>The following constrains <span>$\|(x-1, x-2)\|_2 \le 2tx$</span> and <span>$t, x \ge 0$</span>:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; @variable(model, t)
t

julia&gt; @constraint(model, [t, x, x-1, x-2] in RotatedSecondOrderCone())
[t, x, x - 1, x - 2] ∈ MathOptInterface.RotatedSecondOrderCone(4)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.PSDCone" href="#JuMP.PSDCone"><code>JuMP.PSDCone</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">PSDCone</code></pre><p>Positive semidefinite cone object that can be used to constrain a square matrix to be positive semidefinite in the <a href="constraints.html#JuMP.@constraint"><code>@constraint</code></a> macro. If the matrix has type <code>Symmetric</code> then the columns vectorization (the vector obtained by concatenating the columns) of its upper triangular part is constrained to belong to the <code>MOI.PositiveSemidefiniteConeTriangle</code> set, otherwise its column vectorization is constrained to belong to the <code>MOI.PositiveSemidefiniteConeSquare</code> set.</p><p><strong>Examples</strong></p><p>Consider the following example:</p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model, x)
x

julia&gt; a = [ x 2x
            2x  x];

julia&gt; b = [1 2
            2 4];

julia&gt; @SDconstraint(model, a ⪰ b)
[x - 1, 2 x - 2, 2 x - 2, x - 4] ∈ MathOptInterface.PositiveSemidefiniteConeSquare(2)</code></pre><p>We see in the output of the last command that the matrix the vectorization of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra # For Symmetric

julia&gt; @constraint(model, Symmetric(a - b) in PSDCone())
[x - 1, 2 x - 2, x - 4] ∈ MathOptInterface.PositiveSemidefiniteConeTriangle(2)</code></pre><p>As we see in the output of the last command, the vectorization of only the upper triangular part of the matrix is constrained to belong to the <code>PositiveSemidefiniteConeSquare</code>.</p></div></div></section><h2><a class="nav-anchor" id="Constraint-modifications-1" href="#Constraint-modifications-1">Constraint modifications</a></h2><p><code>JuMP.set_coefficient(constraint, variable, value)</code></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.set_coefficient" href="#JuMP.set_coefficient"><code>JuMP.set_coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_coefficient(constraint::ConstraintRef, variable::VariableRef, value)</code></pre><p>Set the coefficient of <code>variable</code> in the constraint <code>constraint</code> to <code>value</code>.</p><p>Note that prior to this step, JuMP will aggregate multiple terms containing the same variable. For example, given a constraint <code>2x + 3x &lt;= 2</code>, <code>JuMP.set_coefficient(c, x, 4)</code> will create the constraint <code>4x &lt;= 2</code>.</p><pre><code class="language-julia">model = Model()
@variable(model, x)
@constraint(model, con, 2x + 3x &lt;= 2)
JuMP.set_coefficient(con, x, 4)
con

# output

con : 4 x &lt;= 2.0</code></pre></div></div></section><h2><a class="nav-anchor" id="Duals-1" href="#Duals-1">Duals</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.result_dual" href="#JuMP.result_dual"><code>JuMP.result_dual</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">result_dual(cr::ConstraintRef)</code></pre><p>Get the dual value of this constraint in the result returned by a solver. Use <code>has_result_dual</code> to check if a result exists before asking for values. See also <a href="constraints.html#JuMP.shadow_price"><code>shadow_price</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.shadow_price" href="#JuMP.shadow_price"><code>JuMP.shadow_price</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">shadow_price(constraint::ConstraintRef)</code></pre><p>The change in the objective from an infinitesimal relaxation of the constraint. This value is computed from <a href="constraints.html#JuMP.result_dual"><code>result_dual</code></a> and can be queried only when <code>has_result_dual</code> is <code>true</code> and the objective sense is <code>MinSense</code> or <code>MaxSense</code> (not <code>FeasibilitySense</code>). For linear constraints, the shadow prices differ at most in sign from the <code>result_dual</code> value depending on the objective sense.</p><p><strong>Notes</strong></p><ul><li>The function simply translates signs from <code>result_dual</code> and does not validate the conditions needed to guarantee the sensitivity interpretation of the shadow price. The caller is responsible, e.g., for checking whether the solver converged to an optimal primal-dual pair or a proof of infeasibility.</li><li>The computation is based on the current objective sense of the model. If this has changed since the last solve, the results will be incorrect.</li><li>Relaxation of equality constraints (and hence the shadow price) is defined based on which sense of the equality constraint is active.</li></ul></div></div></section><footer><hr/><a class="previous" href="expressions.html"><span class="direction">Previous</span><span class="title">Expressions</span></a><a class="next" href="containers.html"><span class="direction">Next</span><span class="title">Containers</span></a></footer></article></body></html>
